
1.整理同类题型

1.时间、空间复杂度
2.算法思路
3.最简单->优化
4.30min

#binary search model
start = 0,end = len(arr) -1
while(start + 1 < end) #邻近or相等跳出循环
    mid = (start + end) / 2
    mid ==,<>
    A[start]
    A[mid]
    if start + 1 == end 相差一位
    if start == end 重叠
    
Search a 2D Matrix II   
first bad version
Find Peak Search
Search a 2D Matrix II   finish
first bad version       finish
Find Peak Search        finish

Search in Rotated Sorted Array

   
去一半无解的区域或者向一半有解的区域
#翻转算法
局部翻转->整体翻转
    Recover Rotated Sorted Array
    Rotate String  
    Reverse Words in a String
 
#递归算法
递归三要素：
    1.明确递归程序作用：接受什么返回什么 
    2.数据规模减低:处理方法同第一步，数据规模降低(数据性质相同)
    3.明确终止条件
#递归：
    数据结构递归：树；算法递归
#Recursion 获取所以叶子节点和
概念:树的高度是针对总体而言，树的深度是针对每个节点而言

#divide-conquer
本质:分-和 和的数据来自分

Traverse vs Divide Conquer
they are both Recursion algorithm
result in  global parameter Vs Result in return value(能每经过一次，new 一次)


递归是从 head->tail
divide-conquer tail->head

dp：
1.rolling array
2.how wo print path


7.5-7.12 未完成任务
7.13 2
7.14 3
7.15 3
7.16 1


Binary Search Tree Iterator 
In order Successor in binary Search Tree
Search Range in Binary Search Tree
Remove Node in Binary Search Tree
